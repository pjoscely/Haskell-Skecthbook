-- Project Euler
-- https://projecteuler.net/
-- '''
-- Highly divisible triangular number
-- Problem 12
-- The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

-- 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

-- Let us list the factors of the first seven triangle numbers:

 -- 1: 1
 -- 3: 1,3
 -- 6: 1,2,3,6
-- 10: 1,2,5,10
-- 15: 1,3,5,15
-- 21: 1,3,7,21
-- 28: 1,2,4,7,14,28
-- We can see that 28 is the first triangle number to have over five divisors.

-- What is the value of the first triangle number to have over five hundred divisors?
-- ***************************************************************************************
-- Python solution first
-- '''
-- import math
-- #total number of divisiors 
-- def num_of_divisors(num):
--     sum = 0
--     lim = math.sqrt(num)
--     for i in range(1,int(lim)+1):
--         if(num%i == 0):
--             sum+=2
--     if(int(lim)**2 == num):
 --        sum -=1
--     return sum


-- #Start at the 10000 triangle number 
-- for i in range(10000,1000000):
--     tri_num = int((i**2+i)/2)
--     if (num_of_divisors(tri_num)>500):
--         print(i,tri_num)
--         break
-- # Congratulations, the answer you gave to problem 12 is correct.

-- #You are the 217737th person to have solved this problem.

-- #12375 76576500

-- ***************************************************************************************
-- Haskell solution
-- The performance of this solution is very poor nonetheless
-- it is given as an example of what can be done in Haskell by 
-- taking a naive approach and following the Python solution above

-- Test if a number is a perfect square
perfect_square :: Integral a => a -> Bool
perfect_square n = sq * sq == n
    where sq = floor $ sqrt $ (fromIntegral n::Double)

-- Compute number of divisors ignoring in n is perfect square  
num_of_div_raw :: (Integral a2, Num a1) => a2 -> a1
num_of_div_raw n = sum[2|c<-[1..floor $ sqrt $ (fromIntegral n::Double)],n`rem`c == 0]

-- Compute corrected number of divisors
num_of_div :: (Integral a, Num p) => a -> p
num_of_div n = if perfect_square n then num_of_div_raw n -1 else num_of_div_raw n

-- Compute ith triangle number 
tri_num :: Integral a => a -> a
tri_num i = ((i)*(i+1)) `div` 2

-- Compute the index of the required triangle number 
-- Search is restricted to where the solution lies [12000..13000]
answer_index :: Integer
answer_index =  minimum [ i| i<-[12000..13000], (num_of_div.tri_num) i > 500]

-- Compute the triangle number
answer :: Integer
answer = tri_num answer_index 

-- main -> 76576500
-- (6.11 secs, 2,414,500,024 bytes
main :: IO ()
main = do  
    putStrLn$show answer




